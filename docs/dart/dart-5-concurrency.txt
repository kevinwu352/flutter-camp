
异步 ================================================================================

await 只能在 async 方法内被使用

文档里异步的 main 函数
Future<void> main() async { }

普通函数，调用的时候，同步拿到值
String foo() { return "abc"; }
var str = foo();

改成 async 后，返回类型必须变成 Future<String>
Future<String> foo() async { return "abc"; } // 系统会自动创建 Future<String> 实例
var str = foo();        // 类型是 Future<String>
var str = await foo();  // 类型是 String

await 等的是 Future<...>，某函数返回 Future 就可以等它，这函数不用是 async
Future<String> bar() { return Future.value("123"); }
var str = bar();        // 类型是 Future<String>
var str = await bar();  // 类型是 String

对于异步函数，最好 await，如果真的不想等，用 unawaited 明确标记出来
  await doSomething();
  unawaited(doSomething());
linter:       // analysis_options.yaml
  rules:
    unawaited_futures: true
    discarded_futures: true // 不要在同步函数里调异步函数

Flutter 里面推荐用 compute，而不是 Isolate.run
Isolate.run 参数是函数，函数返回 FutureOr<R>。而 run 的返回值是 Future<R>
int slowFib(int n) => n <= 1 ? 1 : slowFib(n - 1) + slowFib(n - 2);
var res = await Isolate.run(() => slowFib(43));
可以给个异步函数字面量，注意那个 async
await Isolate.run(() async { return ...; });



Future 表示异步操作的结果，这是一种承诺，承诺将来会以 value 或 error 结束

等多个异步操作，它们返回值不同，value 是数组
final value = await [getint(), getstr()].wait;
final value = await Future.wait([getint(), getstr()]); // [12, abc]
等多个异步操作，它们的值分别取出来，这里是 Record
final (v1, v2) = await (getint(), getstr()).wait;



Stream 类似于 Publisher
一般遇到错误就结束了，但也能让它继续产生数据和错误
单订阅流只能被 listen 一次，有人订阅才开始产生数据
广播流 ready 后就开始产生数据，新订阅者不会收到以前的数据
流取消以后，下次走到 yield，它就变成一个 return 语句


让流产生错误
Stream<int> stream(int to) async* {
  for (int i = 1; i <= to; i++) {
    if (i == 4) {
      throw Exception('Intentional exception');
    } else {
      yield i;
    }
  }
}
某个流会产生异常，如果直接用 await for 会崩，可以用 handleError 把异常过滤掉
stream = stream.handleError((e) => print(e));


创建 Stream，同步的 Generator 返回 Iterable<int>，这里是异步的 Generator
同步的 yield* 后接数组，异步的后接另一个 Stream
这函数会马上返回一个 Stream<int>，然后当有人订阅后，函数体才会开始执行，真的
Stream<int> asynchronousNaturalsTo(int n) async* {
  int k = 0;
  while (k < n) yield k++;
}

final controller = StreamController<int>(
  onPause: () => print('Paused'),
  onResume: () => print('Resumed'),
  onCancel: () => print('Cancelled'),
  onListen: () => print('Listens'),
);
controller.add(1);
创建个 stream，它背后在运行，main() 退出不了
下面这个流有两个问题：1)没人订阅它也会产生数据；2)无法取消，它会一直产生数据
Stream<int> timedCounter(Duration interval, [int? maxCount]) {
  var controller = StreamController<int>();
  int counter = 0;
  void tick(Timer timer) {
    counter++;
    controller.add(counter); // Ask stream to send counter values as event.
    if (maxCount != null && counter >= maxCount) {
      timer.cancel();
      controller.close(); // Ask stream to shut down and tell listeners.
    }
  }
  Timer.periodic(interval, tick); // BAD: Starts before it has subscribers.
  return controller.stream;
}
var stream = timedCounter(Duration(seconds: 1));
await Future.delayed(const Duration(seconds: 5));
await for (var e in stream) { } // 5 秒后突然收到 12345，然后每秒收到一个
// 这无法收到数据，为何？
// 经研究，不是收不到，是写错了。应该是 stream.listen(print);
// stream.listen((e) => print);


await for (final value in stream) { } // 0 1 2 3... <= 会阻塞后续代码
能用 break/return 退出循环，文档还说会取消订阅这个流

用 listen 方法接收数据，这方法还有 onError / onDone 这些参数。返回值是 StreamSubscription，用于取消
stream.listen((value) { print(value); }); <= 不会阻塞后续代码，但 main() 好像要等它结束？
stream.listen((value) => print(value));
stream.listen(print);
