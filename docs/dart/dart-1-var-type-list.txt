
无 public / private，下划线开头的为 library 私有，好像并非靠程序员自觉，而是编译器保证它不可被外部访问

final val = a ? 1 :
            b ? 2 : 3;

list
  .where((c) => c >= 3)
  .map((c) => c + 10)
  .forEach((c) => print(c));
map((item) { return item.toUpperCase(); })

!> obj.runtimeType 类型是 Type。用 obj is Type，尽量不要用 obj.runtimeType == Type

class WannabeFunction {
  String call(String a, String b, String c) => '$a $b $c!'; // swift 的 callAsFunction
}

!> 空集合上面调用 first/last 会崩

switch 空内容会漏下去，其它不会

通过 getter 获取某个实例后，如果修改此实例的属性，原来的实例的属性也会变。这和 swift 的值类型不一样

无初始值的 late final 都有 setter，注意：有初值的 late final 没 setter

子类不继承命名构造器，要用就自己实现



变量 ================================================================================
String name = '';
var name = 'bob'; // 不能接类型名

bool? b1; // 不用初始化，有默认值
final bool? b1; // 报错，必须要手动初始化

!> final 声明时可以不给值，只要使用前给值就行
final name = 'bob';
late final int a; // 文档里讲到 late 时说它是延迟初始化，但实际上这里有无 late 效果相同

// 后面再给值
final String name;
if (b1) {
  name = 'John';
} else {
  name = 'Jane';
}

!> 类的实例常量必须变成静态常量，即，没有实例常量，只有实例 final
class Foo {
  const age = 10; // 报错
  static const age = 10; // 添加 static
  final age = 10; // 用 final
}

// 这三种写法前后都不能改
const foo = [1, 2, 3]; // 编译时能确定的常量，用这种写法
final foo = const ['one', 'two', 'three'];
final foo = List<String>.unmodifiable(['apple', 'orange', 'pear']);
// 前不可变，后可变，后面可添加新元素
final foo = ['one', 'two', 'three'];

!> final 不能赋给 const，const 可以赋给 const
final foo1 = [1, 2, 3];
const bar1 = foo1; // 报错
const foo2 = [1, 2, 3];
const bar2 = foo2; // 成功



类型 ================================================================================
!> 所有类的基类是 Object，Null 除外
!> 枚举的基类 Enum，Enum 是 Object 的子类吗？
答：文档里 Enum 是抽象接口，且 ReqMethod.post is Object 是真

所有类型全是 class，包括基础类型 int/double
!> int 和 double 能比较大小
!> 没有 unsigned 这类数字，全是 signed

bool
num, int, double
String
Null
List, Map, Set

Records / Functions / Runes / Symbols

!> 5/2 值是 double；5~/2 值是 int 
var x = 5/2;  // 2.5，值是 double，且不能赋给 int 变量，4/2 也不行
int x = 5~/2; // 2  ，值是 int

int.parse('1');
double.parse('1.1');
1.toString();
3.14159.toStringAsFixed(2);


!> Record 用法
Record 类型感觉就是元组，虽然文档说无 Tuple。可以像函数一样有命名参数，且名字是类型的一部分
(int, int) swap((int, int) aa) {
  var (a, b) = aa;
  return (b, a);
} // 这里用的是位置参数。
({int a, bool b}) record = (a: 123, b: true); 这是命名参数

访问起点是 $1，跳过命名部分，再到 $2
var bt = (label: "button",
          icon: "img",
          onPressed: () => print(""),
          )
定义 Record 别名
typedef ButtonItem = ({String label, Icon icon, void Function()? onPressed});


!> 定义字符串
String 单双引号都行，没有 Character 类型
final unicode = '\u{1F60E}'; // 😎
如果是 4 位，能用这写法 '\u2665'，三位五位好像就不行了
这三行会合并成一行，还能用 + 拼接字符串
  final s1 =
    'String '
    'concatenation'
    " even works over line breaks.";

如果 You 换行到第二行行首，效果一样，会忽略这个换行符。但如果 You 在第二行时，前有空格则会保留空格
multiline 前的四个空格会保留，并不会按照最后一行的位置来截断
  final s2 = '''You can create
    multiline strings like this one.
    ''';
因为不会截断，所以如下。我感觉结尾的引号不要新起行了。
  '''a'''; 长度是 1
  '''a
'''; 长度是 2
'''a
  '''; 长度是 4。打印在控制台时，看不见第二行，但长度证明换行和空格确实在

字符串前面加 r 就成原始字符串，内部的转义就不起作用了


!> 空安全
?. 和 ?? 作用和 swift 相同
a ??= b，a 为空时才把 b 赋给 a，等于 a = a ?? b。所以，??= 可能会赋值，?? 一定会赋值

a is int
a is! int
a as int // 有可能会崩，如果不确定，就先用 is 测试一下，相当于 swift 的 as!，没有 as? 对应的写法
我试了，能被 try catch 捕获，所以它是个异常，以后用的时候，最好用 try catch

解包的时候，swift 要 if let，这里 is 判断成功后，里面可以直接用，但花括号后面不行
  final u = get_user();
  if (u is User) {
    u.log();
  }

  String? a;
  a = 'ab'; // 如果赋非空值，后面访问 length 编译通过
  a = null; // 如果赋  空值，后面访问 length 编译失败，貌似 a 的类型根据它被赋的值在变？
  print(a.length);

  int? a = 5 / null;
  int b = a; // 这里能否编译成功，也要看上面赋的值是不是空，所以 a 的类型真的在变？

似乎 a 的类型不是可选一样，给它赋个值，连问号都不要了，为何？
定义的时候加不加问号都行，使用的时候加不加问号也行，似乎没啥关系
  double? a = 5.123;
  print(a.toInt()); // a.toInt() 在 vscode 看到的类型是 int
  print(a?.toInt()); // a?.toInt() 在 vscode 看到的类型是 int?


!> 全局变量/静态变量 都是懒加载的
late 的主旨是：一个非空的变量，我会在将来使用它之前给它赋值。late 有两个作用
1) 懒加载，late 变量后如果给初始值，这就是懒加载。当此属性赋值需要用到 this 时，懒加载就很有用
2) 隐式解包!，访问时如果未初始化会崩（可选也必须初始化），就算访问时加上问号也会崩。这就要自己注意安全了
class Weather {
  late int _temperature = _readThermometer(); // 访问此属性的时候才会初始化，才会调用方法
  int? bbb; // 有默认值，不用初始化，能直接访问
  late int? aaa; // 必须初始化以后才能访问，否则会崩
}
可空变量有默认值 null。可空的类实例成员变量也有默认值

late int theval = foo(); 如果第一次访问它是直接给它设置值，foo() 不会被调用


!> 不能定义新运算符(swift 可以)，但能重载
class Vector {
  final double x, y , z;
  Vector operator +(Vector v) {
    return Vector(x: x + v.x, y: y + v.y, z: z+v.z);
  }
}



集合 ================================================================================
列表
final List<String> list1 = <String>['one', 'two', 'three'];
final list2 = <String>['one', 'two', 'three'];
final list3 = ['one', 'two', 'three'];

[5, 2.0] 类型是 List<num>

const Object i = 3;
const list = [i as int]; // [3]

空感知
[1, ?absentValue, ?presentValue, absentValue, 5]
类型是 List<int?>，如果不要最后的 absentValue，类型是 List<int>
前面加问号时，如果这变量为空，则不会有值加到数组里

展开
final list1 = [1, 2, 3];
final list2 = [0, ...list1];
final list3 = [0, ...?list]; // 可选的时候用这种

if 用法
var items = [
  0,
  if (name == 'kiwi') 10 else if (name == 'pear') 20 else 30, // 可以没有 else if 和 else
  2,
];

Object data = 123;
var typeInfo = [
  if (data case int i) 'Data is an integer: $i',
  if (data case String s) 'Data is a string: $s',
  if (data case bool b) 'Data is a boolean: $b',
  if (data case double d) 'Data is a double: $d',
];

var word = 'hello';
var items = [
  1,
  if (word case String(length: var wordLength)) wordLength, // 如果是字符串，取字符串的长度
  3,
];

var orderDetails = ['Apples', 12, 'bb'];
var summary = [
  'Product: ${orderDetails[0]}',
  if (orderDetails case [_, int qty, _]) 'Quantity: $qty',
  if (orderDetails case [_, _, '']) 'Delivery: Not Started' else 'Delivery: In Progress',
];

for 用法，for 和 if 还能交叉集合起来用
[1, for (var n in numbers) n * n, 7];
[1, for (var x = 5; x > 2; x--) x, 7];



字典，每个 Object 都有 hash，swift 里需要明确实现 Hashable
final gifts = <String, Object>{};
final gifts = { 'first': 'partridge', 'second': 'turtle doves' };

空感知
  var itemsA = {presentKey: absentValue}; // {Apple: null} <String:int?>
  var itemsB = {presentKey: ?absentValue}; // {} <String:int> 为什么又记不住类型？int?呢？应该是 ?absentValue 的作用
  var itemsC = {absentKey: presentValue}; // {null: 3} <String?:int>
  var itemsD = {?absentKey: presentValue}; // {} <String:int>
  var itemsE = {absentKey: absentValue}; // {null: null} <String?:int?>
  var itemsF = {?absentKey: ?absentValue}; // {} <String:int>

if 用法
const map = {if (i is int) i: 'int'};



集合，存 hashCode 不同的值，默认的实现基于 object's identity。如果两个不同实例通过 == 能判断相等，需要重写 hashCode
final abc = {'a', 'b', 'c'};
final abc = Set<String>.unmodifiable(['a', 'b', 'c']);

空集合的声明方式有两种
final names = <String>{};
Set<String> alsoNames = {};
final names = {}; // 这会被当成空字典，类型是 Map<dynamic, dynamic>

if 用法
const set = {if (list is List<int>) ...list};
