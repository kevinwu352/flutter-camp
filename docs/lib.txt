
Expando ???
Finalizer
Invocation

Random().nextInt(10); 0-10
Random().nextBool
Random().nextDouble 无参数，0.0-1.0

JsonCodec 这是类，内部使用 JsonEncoder / JsonDecoder
json 是 JsonCodec 的实例，有俩函数 jsonEncode = json.encode / jsonDecode = json.decode

函数类型可选时，调用如下
  maybeFun?.call(1)

var it = obj.iterator;
while (it.moveNext()) {
  use(it.current);
}




DateTime 是时间，DateFormat 用来格式化，它属于 intl 包
国际化的时候指定显示格式 https://docs.flutter.dev/ui/accessibility-and-internationalization/internationalization#messages-with-dates

DateTime.now() 本地时区
DateTime.timestamp() 零时区
  这俩的时间是相同的，只是不在同一时区。用 now.toUtc() 就变成零时区了

DateTime(2022)
DateTime.utc(2022)
  这俩时间是不一样的，是不同时区的 2022-1-1，如果把时区转换一下就能明显看出来

加载 locale 前，调用：
  await initializeDateFormatting();

默认样式
  print(DateFormat().format(DateTime.now())); // September 10, 2025 2:56:27 PM
预设格式，默认美国
  print(DateFormat.yMMMd().add_Hms().format(DateTime.timestamp())); // Sep 10, 2025 03:22:37
  print(DateFormat.yMMMd().add_Hms().format(DateTime.now()));       // Sep 10, 2025 11:22:37 它们的时间相差了 8 小时
预设格式，自定义 locale
  print(DateFormat.yMEd('en_US').add_Hms().format(DateTime.now())); // Wed, 9/10/2025 11:26:04 没随着系统的设置而变化，为何？
  print(DateFormat.yMEd('zh_TW').add_Hms().format(DateTime.now())); // 2025/9/10（週三） 11:26:04
自定义格式，自定义 locale
  print(DateFormat('EEE, M/d/y', 'en_US').format(DateTime.now())); // Wed, 9/10/2025
  print(DateFormat('EEE, M/d/y', 'zh_TW').format(DateTime.now())); // 週三, 9/10/2025
自定义格式，不需要 locale
  print(DateFormat('yyyy-MM-dd HH:mm:ss').format(DateTime.now())); // 2025-09-10 14:54:49

arb 文件中，只支持预设格式，写个 'yyyy-MM-dd HH:mm:ss' 会报错
  "dt_msg": "Hello, dt:{val}!"
  "@dt_msg": {
    "placeholders": {
      "val": {
        "type": "DateTime",
        "format": "Hms"
      }
    }
  }
"E", "EEEE" // Wed | Wednesday | W
"LLL", "LLLL" // Sep | September
"QQQ", "QQQQ" // Q3 | 3rd quarter
"yQQQ", "yQQQQ" // Q3 2025 | 3rd quarter 2025

"y", "M", "MMM", "MMMM", "d" // 2025 | 9 | Sep | September | 10

"yM", "yMMM", "yMMMM" // 9/2025 | Sep 2025 | September 2025

"Md", "MMMd", "MMMMd" // 9/10 | Sep 10 | September 10
"yMd", "yMMMd", "yMMMMd" // 9/10/2025 | Sep 10, 2025 | September 10, 2025

"MEd", "MMMEd", "MMMMEEEEd" // Wed, 9/10 | Wed, Sep 10 | Wednesday, September 10
"yMEd", "yMMMEd", "yMMMMEEEEd" // Wed, 9/10/2025 | Wed, Sep 10, 2025 | Wednesday, September 10, 2025

"H", "Hm", "Hms" // 07 | 07:37 | 07:37:53
"j", "jm", "jms" // 7 AM | 7:35 AM | 7:35:45 AM
"m", "ms", "s" // 37 | 37:20 | 20




  final val = 1200000;
  // final val = 1200000.5678;
  // final val = 1.5678;
  // final val = 0.345618;

  print(NumberFormat().format(val)); // 1,200,000 | 1,200,000.568 | 1.568
  print(NumberFormat.compact(locale: "zh_TW").format(val)); // 1.2M 120萬 | 120萬 | 1.57
  print(NumberFormat.compactLong().format(val)); // 1.2 million | 1.2 million | 1.57

  // 前缀用什么？优先级递减：symbol(€) > name(JPY) > locale(USD)。有 symbol 用的是单符号，否则是 JPY 这种名字
  print(NumberFormat.currency().format(val)); // USD1,200,000.00 | USD1,200,000.57 | USD1.57
  print(NumberFormat.compactCurrency().format(val)); // USD1.2M | USD1.2M | USD1.57
  // 货币的 name 是 CNY / JPY 这种。如果随便给字符串，位数用 locale 的，前面符号是传的那值
  // 个人感觉 name 和 locale 最好匹配，比如 en_US 和 JPY 感觉很别扭
  // 货币小数点后面的位数是多少？优先级递减：decimalDigits 参数 > name 的 > locale 的
  print(NumberFormat.simpleCurrency().format(val)); // $1,200,000.00 | $1,200,000.57 | $1.57
  print(NumberFormat.compactSimpleCurrency().format(val)); // $1.2M | $1.2M | $1.57

  // 默认三位小数，且是四舍五入
  // 第一个方法会去除末尾的 0，第二个方法会保持 0
  print(NumberFormat.decimalPattern().format(val)); // 0.345678 => 0.346
  print(NumberFormat.decimalPatternDigits(decimalDigits: 2).format(val)); // 0.345678 => 0.35

  // 百分比数，它会把数乘以 100 再加百分号
  print(NumberFormat.percentPattern().format(val)); // 0.345678 => 35%
  print(NumberFormat.decimalPercentPattern(decimalDigits: 2).format(val)); // 0.345678 => 34.57%

  print(NumberFormat.scientificPattern().format(val)); // 1E6




double

isFinite
sign / isNegative

abs

toDouble / toInt
toString
toStringAsExponential(3) // 1.235e+5
toStringAsPrecision(6) // 小数点前后的有效数字个数，123456789.xxx(6) => 1.23457e+8
toStringAsFixed
  0 去掉小数位，也不会有小数点
  n 位数不足会补 0，四舍五入不管正负

ceil x 轴向右，所以 -1.1 => -1
floor x 轴向左，所以 -1.1 => -2
truncate x 轴向内，直接丢弃小数部分
round 四舍五入，所以 -3.2 => -3 / -3.5 => -4
上面四个返回值是 int，~ToDouble 返回值是 double

超过上限或下限，则返回上限或下限
num clamp(num lowerLimit, num upperLimit)

整除后的余数
double remainder(num other)


int

gcd 最大公约数

toRadixString(2) 转成几进制的字符串

toSigned / toUnsigned // 没搞懂这函数？
modInverse / modPow // 没搞懂这函数？
