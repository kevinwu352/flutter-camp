
runApp 分三步
  ensureInitialized 确保 binding 完成
  attach => scheduleAttachRootWidget(app) 把传进去的控件 attach 到 root，包装到一个 View 内
    主要实现 根Widget/根Element根RenderObject 的关联过程
  warmUp => scheduleWarmUpFrame() 尽快渲染一帧，而不是等系统 vsync 信号请求 engine，engine 再请求上层框架
    绘制结束前，会锁定事件分发，避免在这个绘制过程中触发新的重绘

BuildOwner 是 widget framework 的管理类，它跟踪哪些 widget 需要重新构建

渲染流水线：由 vsync 驱动，而 vsync 信号由系统提供
  vsync
  Animate 动画会随 vsync 信号而动，所以第一步先让动画 tick 到下一帧
  Build 调用 build()
  Layout 调用 RenderObject.performLayout()
  Paint 调用 RenderObject.paint()
  最终生成一个 Scene 送往底层，由 GPU 绘制到屏幕上
触发流水线的 vsync 信号是来自引擎，渲染完成以后的场景也是送入引擎来显示
我注：
  先注册 onBeginFrame/onDrawFrame 事件回调，onBeginFrame 之后马上调用 onDrawFrame
  我们调用 scheduleFrame 来请求 frame，Flutter 会在合适的时机调用 onBeginFrame/onDrawFrame
onBeginFrame 的回调 handleBeginFrame 里：
  先将 SchedulerPhase 改成临时阶段，再执行 transientCallbacks 临时任务
  这些临时回调和动画相关，调完以后会清空回调列表
  最后，在 try-catch 的 finally 里，把阶段改为 midFrameMicrotasks
onDrawFrame 的回调 handleDrawFrame 里：
  先改阶段 persistentCallbacks，再依次做持久任务，也就是渲染管线
  再改阶段 postFrameCallbacks，再依次执行任务列表，最后清空任务列表
  最后，在 try-catch 的 finally 里，把阶段改成 idle
在 RendererBinding.initInstances 里会 addPersistentFrameCallback，把 drawFrame 注册到持久任务列表里
貌似持久任务列表里只有 drawFrame 一个任务

渲染管线：当新的 frame 到来时，调用 drawFrame，它做五件事
  先重新构建 widget 树
  更新布局，flushLayout，里面 performLayout
  更新 层合成 信息，flushCompositingBits
  重绘，flushPaint
  上屏，compositeFrame，最终得到一棵 Layer 树，renderView.compositeFrame 做这个事
setState 先用 element.markNeedsBuild 标记 element 为脏，然后将 element 添加到一个脏列表，然后等新的 frame 到来时执行渲染管线

SchedulerPhase 本来只有 idle 和 frame 两种状态，把 frame 细分为四个阶段，所以总共 5 个阶段
  idle 空间状态，没有 frame 处理，表示页面无变化发生，不需要重绘
  transientCallbacks 执行临时任务，只执行一次，完成后会移出队列，典型代表是动画
  midFrameMicrotasks 临时任务产生的微任务
  persistentCallbacks 执行一些持久任务，比如渲染管线那堆方法
  postFrameCallbacks 当前 frame 结束之前执行，通常用于清理工作或请求新的 frame
setState 后，在 ensureVisualUpdate() 里会判断当前调度所处的状态，最终会确保调用 schedumeFrame
  如果是 idle/postFrameCallbacks 状态则调用 scheduleFrame
  其他状态则直接返回，它们正是渲染流水线运行的时候

Flutter 上层框架用 dart 实现，下层引擎用 C++ 实现
Binding 连接 底层引擎 和 上层框架
BindingBase 抽象类，但它有构造器
  GestureBinding 处理 hittest 手势竞技场
  SchedulerBinding onBeginFrame/onDrawFrame/post-frame-callback/non-rendering-task
  ServicesBinding 处理 platform message
  PaintingBinding 图片缓存回收逻辑
  SemanticsBinding
  RendererBinding 连接 render trees 和 引擎
  WidgetsBinding 连接 widgets layer 和 引擎
上面 7 个是 mixin，它们给 ui.PlatformDispatcher.instance 添加事件回调，处理操作系统产生的事件
WidgetsFlutterBinding 类，继承 BindingBase，并混入上面 7 个 mixin
  ensureInitialized 创建类的实例，那些 XXXBinding.instance 拿到的都是这个实例
  BindingBase 构造器会调用 initInstances，这些 mixin 也有这方法，它们被调用的顺序是混入时的顺序
RenderingFlutterBinding 是类，实现了上面前 6 个 mixin。看文档的意思：少用这个，用 WidgetsFlutterBinding
TestDefaultBinaryMessengerBinding 是 mixin
TestWidgetsFlutterBinding 是抽象类

WidgetsBindingObserver 是接口，相当于 UITableViewDelegate，有 App 生命周期/屏幕变化/设备旋转/主题变化 函数
WidgetsBinding.instance.addObserver(this)
didChangeAppLifecycleState: detached/resumed/inactive/hidden/paused

build 阶段不要调用 setState，但可以直接在 build 函数内调用
Widget build(BuildContext context) {
  setState(() => ++index); 这里不是 build 阶段，return 里面的代码才是
  return Text('$index');
}
安全刷新界面用 SchedulerBinding.instance.addPostFrameCallback
  idle, transientCallbacks, midFrameMicrotasks, persistentCallbacks, postFrameCallbacks
也就是在这五个阶段执行完以后，再发起新的刷新任务


========================================

解释 一切皆为小部件 的概念：
一切都是小部件，包括应用程序本身、布局和样式，通过 组合/嵌套 创建复杂的用户界面

BuildContext 是抽象类，Element 类实现了它

从创建到渲染的大体流程：
  根据 Widget 生成 Element
  然后创建相应的 RenderObject 并关联到 Element.renderObject 属性上
  最后再通过 RenderObject 来完成布局排列和绘制

三颗树：
  Widget 树是 Element 树的配置，用来生成 Element 树，由程序员管理
  Element 树对应流水线的 build 阶段，用于连接 控件树和渲染树，将 Widget 变化同步到 Render
  Render 树对应流水线的 layout 和 paint 阶段，还有 层合成、上屏
build 虽然在 Widget 实现，但调用在 Element 里面

RenderObject.parent 指向渲染树中自己的父节点
RenderObject.parentData 是一个预留变量，保存布局信息，虽然是子节点的属性，但设置和使用都在父节点
RenderObject 的两个子类 RenderBox/RenderSliver 分别实现 基于 RenderBox 的盒模型布局和基于 Sliver 的按需加载模型
RenderObject 有一个布局边界节点的概念，如果当前节点布局发生变化后，自身到其布局边界节点路径上的所有的节点都需要 relayout
  有四种情况可以成为边界节点，原则是：边界节点自身大小变化不会影响父组件
  a)父尺寸不依赖于自己时，向子传递 parentUsesSize=false
  b)自己尺寸只依赖于父给的约束，子尺寸不影响自己时，自己的 sizedByParent=true
  c)自己收到紧约束时，子尺寸不影响自己，类似于 b
  d)根组件
布局发生变化时，调用 markNeedsLayout 将自己到边界路径上的所有节点标记为脏
然后请求新的 frame，新的 frame 会对它们进行重新布局，在 drawFrame 里 pipeline.flushLayout()

State 持有对应的 Widget 和 Element(context)

Widget
  StatelessWidget
  StatefulWidget
  RenderObjectWidget
Widget 有 createElement 方法，Widget/Element 树的节点一一对应
RenderObjectWidget 有 createRenderObject 方法，所以 StatelessWidget/StatefulWidget 在渲染树上不会有对应的

RenderObjectWidget 有三个比较重要的子类：
  LeafRenderObjectWidget
  SingleChildRenderObjectWidget
  MultiChildRenderObjectWidget
如果有一个 XXXRenderObjectWidget，它的 createElement() 通常会返回一个 XXXRenderObjectElement

Layout 过程主要是确定每个组件的布局信息（大小和位置），布局过程如下：
  父节点向子节点传递约束，限制子节点的最大和最小宽高
  子节点根据约束确定自己的大小
  父节点根据自身布局规则，确定每个子节点在父节点空间中的位置，用偏移 offset 表示
  递归整个过程，确定每个节点的大小和位置
可以看到，组件的大小由自身决定，组件的位置由父组件决定

RenderObject.performLayout() 主要做这几个事情
  如果有子组件，先递归对子组件进行布局。child.layout(...)，后面会获取子的 size，向下传递的是约束，和收到的可能不一样
  根据子尺寸算出自己尺寸，赋值给自己的 size 属性
  算出子的偏移，保存到 parentData，绘制的时候会用到

========================================


dart 是值传递，但有点不一样
把 int 传递给一个函数，函数内部修改 int 的值，原来的 int 不受影响
把 Obj 传递给一个函数，函数内部修改 obj 的属性，原来的 obj 的属性变了
答：
  把 int 传递给函数，函数内部只能 val = 10，给形参赋新值，原来的 int 不受影响
  把 Obj 传递给函数，函数内部如果修改 obj = Obj(111)，也是给形参赋新值，原来的 obj 不受影响
    但是，如果 obj.value = 111，修改的是形参的属性，原来的 obj 会受在影响


位置可选参数在方括号 [] 内定义，可以按定义顺序传递给函数
命名可选参数在花括号 {} 内定义，可以通过指定名称的方式以任意顺序传递给函数


能在动态类型（dynamic）上调用扩展的方法吗？
不能，在 Dart 中，扩展方法是静态解析的，因此不能在动态类型上调用


mixins 允许你将共享的功能分散到多个类中，而不是在单一类的层次结构中
在不修改类的情况下，添加功能或属性，增强了代码的灵活性
类只能直接继承自一个父类，但可以使用多个 mixins
好处：代码复用/突破单继承限制/分离功能方便测试


既然 Dart 不存在多线程，那如何进行多任务并行？
Dart 当中提供了一个类似于新线程，但是不共享内存的独立运行的 worker - isolate
一个 Isolate 对象其实就是一个 isolate 执行环境的引用，一般来说我们都是通过当前的 isolate 去控制其它 isolate 完成彼此之间的交互
可以使用 Isolate.spawn 返回一个新的实例，两个 isolate 之间使用 SendPort 相互发送消息，而 isolate 中也存在了一个与之对应的 ReceivePort 接受消息用来处理
但是我们需要注意的是，ReceivePort 和 SendPort 在每个 isolate 都有一对，只有同一个 isolate 中的 ReceivePort 才能接受到当前类的 SendPort 发送的消息并且处理

可以通过 Platform Channel 让 Dart 代码和原生代码通信：
  MethodChannel：用于传递方法调用。支持数据双向传递，有返回值
    Flutter 主动调用原生功能，原生返回一个值给 Flutter
    一次性的，相当于 HTTP 请求，一问一答
    获取设备信息、调用原生相机 API、调用原生 SDK 功能
  EventChannel：用于数据流的通信。仅支持数据单向传递，无返回值
    原生发生某事件，原生主动通知 Flutter
    事件可能会发生多次，所以是数据流，无法回复
    地理位置变化、传感器数据、网络状态变化
  BasicMessageChannel：用于传递字符串和二进制数据。支持数据双向传递，有返回值
    原生和 Flutter 都能 channel.setMessageHandler 监听对面发来的消息（里面能 reply），都能主动 send 给对面
    比较灵活，适合需要双向、持续性数据交换
    传递文本消息、简单的配置数据，或作为自定义协议的基础
    可以实现 MethodChannel 和 EventChannel 的功能，相当于一个自由度更高的选项吧
制作插件就是用这三个 channel，有两种方式
  1 可以直接写在工程里
  2 可以写成一个 package，这样可以给其它项目用，用的时候 import 那个 package
package 还能细分一下：它们开发流程一样，只有插件要编写原生功能
  1 只有 dart 代码的包
  2 包含 iOS/Android 原生功能的插件


Future 有三种状态：
  Pending/Completed/Error
Stream 有三种状态：
  Not started/Done/Error


========================================


hot reload 保持当前状态。用户输入、动画等
hot restart 清除当前状态并重启应用。修改全局状态、依赖项、初始化方法或其他需要重置的逻辑时
热重载允许开发人员立即看到对代码的更改，而不会丢失应用的状态。它通过立即反映代码更改来加速开发过程
热重启则重新构建整个应用，包括其状态。在对应用程序的依赖项或初始化代码进行更改时很有用

Debug 下是 JIT 模式
Release 下是 AOT 模式


InheritedWidget 用于在 Widget 树中向下传递数据
它允许子 Widget 访问其祖先 Widget 中提供的数据，避免逐层传递，数据变化时依赖此数据的视图会重建
InheritedWidget：适合简单的状态管理，使用较为底层，需要手动实现状态和通知
  可能导致不必要的重建
Provider：基于 InheritedWidget，提供更高级和易用的 API，适合中大型应用中的状态管理
  自动处理依赖关系的重建

(1) Provider 基于 InheritedWidget 和 Listenable，它只能向下传递依赖对象
    数据更新靠的是 ChangeNotifier 和 ListenableBuilder 相关类
    它严格依赖于 BuildContext
    特点是简单，非常简单
(2) GetX 的状态管理不是基于 InheritedWidget 或 Listenable 来实现的，它用自己的基于 Rx 的方式来实现状态管理和响应式编程
    它有自己的数据类型 RxInt/RxString
    除了状态管理，它还有其它功能，路由/国际化/改主题/键值对存储/弹SnackBar
(3) Riverpod 是 Provider 的作者开发的，不依赖 InheritedWidget 所以不依赖 BuildContext
    它里面的 Provider 和 Provider 库没有关系
    状态不是存在 provider 中的，是在 ProviderContainer 中，ProviderScope 会创建 container，这有好处
    感觉有点繁琐，依赖有几个，六种 provider
    写 ViewModel 时，状态要打包成一个类，逻辑打包成一个类
    有个 ref 参数，和 context 类似，相当于引入了另外一棵树
(4) BLOC


Keys 在构建和更新 Widget 时起到重要作用，尤其是在涉及到状态管理、列表和动画时
GlobalKey / ValueKey / ObjectKey / UniqueKey
使用 GlobalKey 时
  可以在 Widget 重建时保留其状态
  从不同的地方访问同一个 Widget 的状态
  在 Widget 的外部调用其状态方法，比如在按钮方法中 formKey.currentState?.validate()，表单是 StatefulWidget，这里访问它的状态


SizedBox：
  当你只需要指定一个小部件的大小时，使用 SizedBox 更为简洁和高效
  适合用于创建空白空间或简单的尺寸控制
Container：
  当你需要更复杂的样式或布局时（边距/背景色/边框），使用 Container 更为合适
  适合用于构建自定义的 UI 元素
Container 小部件的 color 和 decoration 属性不能同时使用


Visibility：控制小部件的显示和隐藏，同时保留其在布局中的空间（要设置三个属性）
Offstage：将小部件完全移出可见区域，不占用任何布局空间，适合优化性能和条件渲染
Opacity：控制小部件的透明度，适用于渐变效果和视觉提示


resizeToAvoidBottomInset 使用场景：输入框在底部/聊天应用


自定义绘制，继承 CustomPainter 类并实现 paint() 和 shouldRepaint() 方法


向 Column 中添加 ListView 的方式：
  显式设置 ListView 高度
  在 ListView 上使用 shrinkWrap 属性
  用 Expanded 封装 ListView
