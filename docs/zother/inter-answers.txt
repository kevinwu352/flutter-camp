
runApp 分三步
  ensureInitialized 确保 binding 完成
  attach => scheduleAttachRootWidget(app) 把传进去的控件 attach 到 root，包装到一个 View 内
  warmUp => scheduleWarmUpFrame() 尽快渲染一帧，而不是等系统 vsync 信号请求 engine，engine 再请求上层框架

渲染流水线：由 vsync 驱动，而 vsync 信号由系统提供
  vsync
  Animate 动画会随 vsync 信号而动，所以第一步先让动画 tick 到下一帧
  Build 调用 build()
  Layout 调用 RenderObject.performLayout()
  Paint 调用 RenderObject.paint()
  最终生成一个 Scene 送往底层，由 GPU 绘制到屏幕上
触发流水线的 vsync 信号是来自引擎，渲染完成以后的场景也是送入引擎来显示

Flutter 上层框架用 dart 实现，下层引擎用 C++ 实现
Binding 连接 底层引擎 和 上层框架
BindingBase 抽象类，但它有构造器
  GestureBinding 处理 hittest 手势竞技场
  SchedulerBinding onBeginFrame/onDrawFrame/post-frame-callback/non-rendering-task
  ServicesBinding 处理 platform message
  PaintingBinding 图片缓存回收逻辑
  SemanticsBinding
  RendererBinding 连接 render trees 和 引擎
  WidgetsBinding 连接 widgets layer 和 引擎
上面 7 个是 mixin，它们给 ui.PlatformDispatcher.instance 添加事件回调，处理操作系统产生的事件
WidgetsFlutterBinding 类，继承 BindingBase，并混入上面 7 个 mixin
  ensureInitialized 创建类的实例，那些 XXXBinding.instance 拿到的都是这个实例
  BindingBase 构造器会调用 initInstances，这些 mixin 也有这方法，它们被调用的顺序是混入时的顺序
RenderingFlutterBinding 是类，实现了上面前 6 个 mixin。看文档的意思：少用这个，用 WidgetsFlutterBinding
TestDefaultBinaryMessengerBinding 是 mixin
TestWidgetsFlutterBinding 是抽象类

WidgetsBindingObserver 是接口，相当于 UITableViewDelegate，有 App 生命周期/屏幕变化/设备旋转/主题变化 函数
WidgetsBinding.instance.addObserver(this)


========================================

解释 一切皆为小部件 的概念：
一切都是小部件，包括应用程序本身、布局和样式，通过 组合/嵌套 创建复杂的用户界面

三颗树：
  Widget 树是 Element 树的配置，用来生成 Element 树，由程序员管理
  Element 树对应流水线的 build 阶段，用于连接 控件树和渲染树，将 Widget 变化同步到 Render
  Render 树对应流水线的 layout 和 paint 阶段

State 持有对应的 Widget 和 Element(context)

Widget
  StatelessWidget
  StatefulWidget
  RenderObjectWidget
Widget 有 createElement 方法，Widget/Element 树的节点一一对应
RenderObjectWidget 有 createRenderObject 方法，所以 StatelessWidget/StatefulWidget 在渲染树上不会有对应的

RenderObjectWidget 有三个比较重要的子类：
  LeafRenderObjectWidget
  SingleChildRenderObjectWidget
  MultiChildRenderObjectWidget
如果有一个 XXXRenderObjectWidget，它的 createElement() 通常会返回一个 XXXRenderObjectElement

Layout 过程主要是确定每个组件的布局信息（大小和位置），布局过程如下：
  父节点向子节点传递约束，限制子节点的最大和最小宽高
  子节点根据约束确定自己的大小
  父节点根据自身布局规则，确定每个子节点在父节点空间中的位置，用偏移 offset 表示
  递归整个过程，确定每个节点的大小和位置
可以看到，组件的大小由自身决定，组件的位置由父组件决定


========================================


位置可选参数在方括号 [] 内定义，可以按定义顺序传递给函数
命名可选参数在花括号 {} 内定义，可以通过指定名称的方式以任意顺序传递给函数


能在动态类型（dynamic）上调用扩展的方法吗？
不能，在 Dart 中，扩展方法是静态解析的，因此不能在动态类型上调用


mixins 允许你将共享的功能分散到多个类中，而不是在单一类的层次结构中
在不修改类的情况下，添加功能或属性，增强了代码的灵活性
类只能直接继承自一个父类，但可以使用多个 mixins


Dart 在单线程中是以消息循环机制来运行的，包含两个任务队列 微任务队列 事件队列，main() 执行完后，消息循环机制便启动了

既然 Dart 不存在多线程，那如何进行多任务并行？
Dart 当中提供了一个类似于新线程，但是不共享内存的独立运行的 worker - isolate
一个 Isolate 对象其实就是一个 isolate 执行环境的引用，一般来说我们都是通过当前的 isolate 去控制其它 isolate 完成彼此之间的交互
可以使用 Isolate.spawn 返回一个新的实例，两个 isolate 之间使用 SendPort 相互发送消息，而 isolate 中也存在了一个与之对应的 ReceivePort 接受消息用来处理
但是我们需要注意的是，ReceivePort 和 SendPort 在每个 isolate 都有一对，只有同一个 isolate 中的 ReceivePort 才能接受到当前类的 SendPort 发送的消息并且处理

可以通过 Platform Channel 让 Dart 代码和原生代码通信：
  BasicMessageChannel：用于传递字符串和半结构化的信息
  MethodChannel：用于传递方法调用（method invocation）
  EventChanne l：用于数据流（event streams）的通信


Future 有三种状态：
  未完成（Pending）
  已完成（Completed）
  失败（Error）
Stream 有三种状态：
  未开始（Not started）
  已完成（Done）
  失败（Error）


========================================


hot reload 保持当前状态。用户输入、动画等
hot restart 清除当前状态并重启应用。修改全局状态、依赖项、初始化方法或其他需要重置的逻辑时
热重载允许开发人员立即看到对代码的更改，而不会丢失应用的状态。它通过立即反映代码更改来加速开发过程
热重启则重新构建整个应用，包括其状态。在对应用程序的依赖项或初始化代码进行更改时很有用

Debug 下是 JIT 模式
Release 下是 AOT 模式


InheritedWidget 用于在 Widget 树中向下传递数据
它允许子 Widget 访问其祖先 Widget 中提供的数据，避免逐层传递，数据变化时依赖此数据的视图会重建
InheritedWidget：适合简单的状态管理，使用较为底层，需要手动实现状态和通知
  可能导致不必要的重建
Provider：基于 InheritedWidget，提供更高级和易用的 API，适合中大型应用中的状态管理
  自动处理依赖关系的重建


Keys 在构建和更新 Widget 时起到重要作用，尤其是在涉及到状态管理、列表和动画时
GlobalKey / ValueKey / ObjectKey / UniqueKey
使用 GlobalKey 时
  可以在 Widget 重建时保留其状态
  从不同的地方访问同一个 Widget 的状态
  在 Widget 的外部调用其状态方法，比如在表单中验证字段


SizedBox：
  当你只需要指定一个小部件的大小时，使用 SizedBox 更为简洁和高效
  适合用于创建空白空间或简单的尺寸控制
Container：
  当你需要更复杂的样式或布局时（边距/背景色/边框），使用 Container 更为合适
  适合用于构建自定义的 UI 元素
Container 小部件的 color 和 decoration 属性不能同时使用


Offstage：将小部件完全移出可见区域，不占用任何布局空间，适合优化性能和条件渲染
Visibility：控制小部件的显示和隐藏，同时保留其在布局中的空间（要设置三个属性）
Opacity：控制小部件的透明度，适用于渐变效果和视觉提示


自定义绘制，扩展 CustomPainter 类并实现 paint() 和 shouldRepaint() 方法


向 Column 中添加 ListView 的方式：
  显式设置 ListView 高度
  在 ListView 上使用 shrinkWrap 属性
  用 Expanded 封装 ListView
