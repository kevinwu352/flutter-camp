三种构建模式
flutter run // 能启动模拟器，应该就是 F5
flutter run --profile
flutter build ios --release // 发布的时候用这个，打出 release 的 App.framework 和 Flutter.framework，再用 xcode archive 上传
flutter build ipa // 直接编译成 ipa，然后用 Apple Transport App 去上传
flutter build ipa --export-method enterprise // 导出企业版

开启布局边框
import 'package:flutter/rendering.dart';
void main() {
  debugPaintSizeEnabled = true;
  runApp(const MyApp());
}

注意这个样式的用法
final iconList = DefaultTextStyle.merge(
  style: descTextStyle,
  child: ,
);

可以用来生成固定数量的子视图
List<int>.generate(10, (i) => i * i)

一个看不见，占位0的视图
SizedBox.shrink()

文档说：推荐把 Scaffold 的子用 SafeArea 包起来




支持的字体类型
OpenType font collections: .ttc
TrueType fonts: .ttf
OpenType fonts: .otf


系统定义的回调 ValueChanged
final ValueChanged<bool> onChanged;


看看这个接口的定义，带默认实现的，实现它的类只需要实现一个方法即可
abstract interface class Comparable<T> {
  int compareTo(T other);
  static int compare(Comparable a, Comparable b) => a.compareTo(b);
}

================================================================================


FractionalTranslation 按照子的百分比进行偏移


BackdropFilter 用来做高斯模糊，视频里说效果不是加到它的 child 上的，而是它背后
BackdropFilter(
  filter: ImageFilter.blur(sigmaX: 0.5, sigmaY: 0.5),
  child: Container(color: Colors.black.withValues(alpha: 0)),
)
用 Stack，然后把它盖在其它控件上面



ClipRRect 用于把子内容切圆角
ClipRRect(
  borderRadius: BorderRadius.circular(20),
  child: Image.asset(...)
)

class HeroWidget extends Stateless {
  build() {
    return Hero(
      tag: 'hero1'
      child: Text('abc')
    )
  }
}
















根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 Element 类。
根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自 RenderObject 类。
根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 Layer 类。

Widget 和 Element 是一一对应的，但并不和 RenderObject 一一对应。比如 StatelessWidget 和 StatefulWidget 都没有对应的 RenderObject


有状态和无状态控件是用于组合控件用的，那些基础控件相当于积木块，而这些积木块有些不是有状态和无状态的子类，而是继承于 RenderObject，所以，可以用 RenderObject 来自定义控件



didChangeDependencies
子 widget 很少会重写此方法，因为在依赖改变后 Flutter 框架也都会调用build()方法重新构建组件树。
如果需要在依赖改变后执行一些昂贵的操作，比如网络请求，最好的方式是在 didChangeDependencies 中，避免在 build 中做昂贵操作


撑大 Scaffold 的方式
      // body: ConstrainedBox(
      //   constraints: BoxConstraints.expand(),
      //   child: Stack(
      //     children: [
      //       // ...
      //     ],
      //   ),
      // ),


只在 debug 版本打印日志的技巧
assert(() {
  print('${tag ?? key ?? child}: $constraints');
  return true;
}());