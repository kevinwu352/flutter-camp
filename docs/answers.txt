Flutter 渲染机制
Flutter 异步机制

Flutter 编译产物
Flutter 编译流程
Flutter 启动过程
Flutter Plugin注册记载过程
Flutter 图片加载过程

离屏渲染？
flutter的图片加载过程，自定义ImageCache作用？
单个控件本身就特别复杂，渲染耗时本身就超过16ms，应该怎么去优化？如果附带了动画的话，有什么需要注意点和优化的部分？

渲染到上屏过程？
skia和openGL，什么时候会选择skia，什么时候会选择直接用openGL，openGL的顶点和片段着色器？
光栅化、光栅缓存？
GIF、Lottie或者其他特效拉满之类的动画的优化方案？



========================================

StatefulWidget 生命周期，createState() 以后：
  mounted == true 
  initState() 
  didChangeDependencies() 
  build()  
  didUpdateWidget() 
  setState() 
  deactivate() 
  dispose() 
  mounted == false


hot reload 保持当前状态。用户输入、动画等
hot restart 清除当前状态并重启应用。修改全局状态、依赖项、初始化方法或其他需要重置的逻辑时
热重载允许开发人员立即看到对代码的更改，而不会丢失应用的状态。它通过立即反映代码更改来加速开发过程。
热重启则重新构建整个应用，包括其状态。在对应用程序的依赖项或初始化代码进行更改时很有用。


InheritedWidget 用于在 Widget 树中向下传递数据。它允许子 Widget 访问其祖先 Widget 中提供的数据。避免逐层传递。数据变化时依赖此数据的视图会重建。


Keys 在构建和更新 Widget 时起到重要作用，尤其是在涉及到状态管理、列表和动画时。
GlobalKey / ValueKey / ObjectKey / UniqueKey
使用 GlobalKey 时，可以在 Widget 重建时保留其状态。
GlobalKey 允许你从不同的地方访问同一个 Widget 的状态。
使用 GlobalKey，你可以在 Widget 的外部调用其状态方法，比如在表单中验证字段。


Tween 用于定义动画起始值和结束值，它帮助你在动画的不同状态之间插值（interpolate）
AnimationController 是一个特殊的 Animation，它可以控制动画的播放。它负责管理动画的生命周期，包括启动、停止、反转等


SizedBox：
  当你只需要指定一个小部件的大小时，使用 SizedBox 更为简洁和高效。
  适合用于创建空白空间或简单的尺寸控制。
Container：
  当你需要更复杂的样式或布局时（边距/背景色/边框），使用 Container 更为合适。
  适合用于构建自定义的 UI 元素。
Container 小部件的 color 和 decoration 属性不能同时使用


Visibility：控制小部件的显示和隐藏，同时保留其在布局中的空间。
Opacity：控制小部件的透明度，适用于渐变效果和视觉提示。
Offstage：将小部件完全移出可见区域，不占用任何布局空间，适合优化性能和条件渲染。


TextEditingController 读取、修改和清空文本内容


ListView 的 reverse 属性可以让列表的滚动方向反转，即从底部开始向顶部滚动，比如聊天应用


InheritedWidget：适合简单的状态管理，使用较为底层，需要手动实现状态和通知。
  可能导致不必要的重建
Provider：基于 InheritedWidget，提供更高级和易用的 API，适合中大型应用中的状态管理。
  自动处理依赖关系的重建


单实例（Singleton）：
  在整个应用生命周期内保持唯一，适用于全局状态和资源共享。
  个人理解：能用类名找到此实例
作用域实例（Scoped Instance）：
  仅在特定上下文或生命周期内有效，适用于局部状态和资源管理。
  个人理解：要用 context 才能找到，如 Provider.of<Counter>(context)


vsync 是一个用于动画的概念，垂直同步。它通常涉及到动画的帧更新，以确保动画的流畅性和性能。vsync 的主要作用是在动画中控制帧的绘制频率，以减少不必要的绘制和提高性能。
vsync 基本上是跟踪屏幕的，因此当屏幕未显示时 Flutter 不会渲染动画


mixins 允许你将共享的功能分散到多个类中，而不是在单一类的层次结构中
在不修改类的情况下，添加功能或属性，增强了代码的灵活性
类只能直接继承自一个父类，但可以使用多个 mixins


WidgetsBindingObserver 是一个用于监听应用生命周期和系统事件的接口。通过实现这个接口，你可以在特定事件发生时接收通知，从而执行相应的操作
当你需要在应用的生命周期状态变化时（如从后台返回到前台）执行某些操作时
监听屏幕尺寸变化、设备旋转、系统主题变化等事件
在应用的生命周期内监控性能指标，例如启动时间、帧率等
WidgetsBinding.instance.addObserver(this);


第一次构建 Flutter 应用程序时，通常会比平时花费更长的时间，因为 Flutter 会构建特定于设备的 IPA 或 APK 文件。在这个过程中，使用 Xcode 和 Gradle 来构建文件，这通常需要很长时间。


Future 有三种状态：未完成（Pending）、已完成（Completed）和失败（Error）
Stream 也有三种状态：未开始（Not started）、已完成（Done）和失败（Error）


runApp() 函数来启动 Flutter 应用，启动应用并将指定的 Widget 作为应用的根 Widget



========================================

Dart 在单线程中是以消息循环机制来运行的，包含两个任务队列 微任务队列 事件队列。 入口函数 main() 执行完后，消息循环机制便启动了。首先会按照先进先出的顺序逐个执行微任务队列中的任务，当所有微任务队列执行完后便开始执行事件队列中的任务，事件任务执行完毕后再去执行微任务，如此循环往复，生生不息。

既然 Dart 不存在多线程，那如何进行多任务并行？
Dart 当中提供了一个类似于新线程，但是不共享内存的独立运行的 worker - isolate。
一个Isolate对象其实就是一个isolate执行环境的引用，一般来说我们都是通过当前的isolate去控制其他的isolate完成彼此之间的交互，而当我们想要创建一个新的Isolate可以使用Isolate.spawn方法获取返回的一个新的isolate对象，两个isolate之间使用SendPort相互发送消息，而isolate中也存在了一个与之对应的ReceivePort接受消息用来处理，但是我们需要注意的是，ReceivePort和SendPort在每个isolate都有一对，只有同一个isolate中的ReceivePort才能接受到当前类的SendPort发送的消息并且处理。


Debug 下是 JIT 模式，Release 下是 AOT 模式

可以通过 Platform Channel 让 Dart 代码和原生代码通信的：
  BasicMessageChannel：用于传递字符串和半结构化的信息。
  MethodChannel：用于传递方法调用（method invocation）。
  EventChanne l：用于数据流（event streams）的通信。

解释 一切皆为小部件 的概念
一切都是小部件，包括应用程序本身。小部件是应用程序的构建块，它们可以组合和嵌套以创建复杂的用户界面。甚至应用程序的布局和样式都是通过组合和配置小部件实现的

无状态小部件是不可变的，没有任何内部状态。它们仅基于提供给它们的输入来渲染 UI。
有状态小部件有可变状态，可以随时间变化。它们可以被多次更新和重建，反映其内部状态的变化。

Flutter 渲染是如何工作的，即小部件树是什么？
使用三树架构进行渲染：小部件树、元素树、渲染树。小部件树表示 UI，元素树连接小部件树和渲染树，而渲染树处理布局和绘制。
Element 依赖 Widget，Render 依赖 Element
Element 持有 Widget 和 Render，连接他俩，将 Widget 的变化同步到 Render

如何在 Flutter 中使用自定义绘制？
通过扩展 CustomPainter 类并实现 paint() 和 shouldRepaint() 方法来进行自定义绘制。

位置可选参数和命名可选参数有什么区别？
位置可选参数在方括号 [] 内定义，可以按定义顺序传递给函数。命名可选参数在花括号 {} 内定义，可以通过指定名称的方式以任意顺序传递给函数。

我们能在动态类型上调用扩展的方法吗？
不能，在 Dart 中，扩展方法是静态解析的，因此不能在动态类型上调用。

在 Dart 中，通过添加 factory 关键字来创建工厂构造函数。这些构造函数可以返回子类型甚至 null。

通过使用 FocusScope.of(context).unfocus() 以编程方式关闭键盘。

向 Column 中添加 ListView 的方式有哪些？
  显式设置 ListView 的高度
  在 ListView 上使用 shrinkWrap 属性
  用 Expanded 封装 ListView 来

自定义 View 流程
  已有控件继承/组合
  自定义 widget，用 paint / canvas 绘制

dart 是值传递，强引用

















