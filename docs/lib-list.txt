
list1 + list2
  同类型的可以相加，类型不同则不行

List.empty

List<int>.filled(5, 0)
  用 0 填充一个长度为 5 的数组

List<E>.generate
  通过 length 和 generator 产生一个数组

List.from(elements)
  复制另一个数组
  elements 的类型和返回的类型可以不一样，通常用于 down-cast，具体见文档
List<E>.of(elements)
  复制另一个数组
  elements 的类型和返回类型是一样的

List<E>.unmodifiable


reversed / shuffle

sort((a, b) => a.length.compareTo(b.length))
  注意升序的写法

add
addAll 追加另一个 Iterable

insert 将 n 位置上的元素后移。n 可以是 length
insertAll

list.setAll(1, ['bee', 'sea'])
  从 1 位置开始，将新数据元素拿进来替换旧的
  list.length 不会改变，新数组太长会崩

clear

asMap
  {0: fee, 1: fi, 2: fo}

toList
toSet

list.sublist(1, 3)
  1,2 位置的元素，返回类型是 List<E>
  getRange 返回类型是 Iterable<E>

whereType
  不给类型就是全部元素
  final list1 = [1, 2, 'aa', true];
  final list2 = list1.whereType<int>();


indexOf('re', 2)
indexWhere
  从 2 这个位置往后找，如果 2 是 're'，则返回 2
  没找到返回 -1
lastIndexOf('re', 2)
lastIndexWhere
  从 2 这个位置往前找，如果 2 是 're'，则返回 2


fillRange(1, 3, 'new')
  把 1 2 位置的元素替换成 'new'，3 是 end 不是 length，且不包括 end
  替换全部元素是 0-length
  start == end，是有效的
getRange(start, end)
  获取子序列 Iterable
  先 list.getRange，再修改 list 内容，getRange 得到的也会变，它俩不是独立的
    final colors = <String>['red', 'green', 'blue', 'orange', 'pink'];
    final range = colors.getRange(0, 3);
    print(range.join(', ')); // red, green, blue
    colors.fillRange(0, 5, '111');
    print(range.join(', ')); // 111, 111, 111
replaceRange(1, 4, replacements)
  fillRange 不改变数组长度，这个可能会改变
removeRange(1, 4)
  移除 1,2,3 位置上的元素
list1.setRange(1, 3, list2, 5)
  list1 的 1,2 有两个位置，将 list2 跳过前 5 个元素，即 5 这个位置开始，取 2 个元素放过去
  list2 数据不足会崩


bool remove(Object? value)
  只移除找到的第一个，如果移除成功返回 true
removeAt(2)
  越界会崩，返回被移除的元素
removeLast
  空流会崩，返回被移除的元素
removeWhere
  移除所有符合条件的
retainWhere((it) => it.length == 3)
  保留所有符合条件的
